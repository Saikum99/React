**---------------------- React Notes -----------------------------**

**Day-1 :**

node -v 	-- to check the version of the node
npx create-react-app my-app	--to create react app with basic structure
npm start	-- to start the app(need to run to go to inside the folder "my-app")

Day-2:
Package.json	--contains all the required libraries that are declared like versions
ReactApp	--contains only one index page (Present in public folder)
--All the components are rendered in index under div with id called root
--this happens because of index.js which is entry point
--Node modules contains all the packages
--npm install packageName (used to install packages)
--to access a component we have to write like this
<ComponetName />
--all the components are rendered in index.js
--package-lock.json	--locks the version of the package to use same version for all developers
--the code writing in components is not html it is JSX(javascript XML)
--React.CreateElement("h1",{},"This is head")	--this is used for creating elements in react
above the 2nd object is the parameters to the tag like style etc
--but it heavy for large page
--So Bable(a tool) came to convert the jsx code to react element
--in JSX we call elements and also functions
let head=<h2>Hi</h2>	this is posible


**Day-3 :**

--Inline styling in react is written as object form inside the {}

Ex: <h1 style = { {color:red, backgroundColor:blue} }></h1>

--here backgroundColor is must be in Camal casing not like background-color

exports are 2 types

1. named	declare export before the class
2. default	declare at the end of the file

--In a file many named exports will be present but only one default export

--default exports can be declares any name in import but named exports must have the same name and imported using like  "{App}"

Ex: 
For import--
import App,{About} from "./Tab"	(here About is named and App is default)
For export--
default -- export default App
named -- export class();

--In react class declaration for element is declared using the className;
Ex: <h1 className="Head"></h1>

--index.module.css, a file created like this which is called as css modules in react which contains all the styles and the extension must me ".module.css"
--we have import like this	(import styles as "./index.module.css")
and access like this	(styles.property) why because it will return an object

--direct css import will create confusion because if we use the same class name for other elements, the styles will be applied to that element also without necessary
direct import	--import "./index.css"

--<React.Fragment>
<h2>This is heading</h2>
<p>This is para</p>
</React.Fragment>
--the above is used to return multiple elements without div
--in general we are allowed to return only one element, so to multiple we need to put inside a div, but it will create an extra div which is not required. So we use Fragment
-- the short hand property for Fragment is 
<>
</>

--Components can be created in 2 ways in react 
1. class based
2. function based
Now a days only function based are creating.
Ex: For class component
class App extends Component {
  //Count = 0;
  state = {
    Count: 0
  }
  handleInc() {
    this.setState({ Count: this.state.Count + 1 })
  }
  handleDec() {
    this.setState({ Count: this.state.Count - 1 })
  }
  render() {
    return (
      <>
        <button onClick={() => { this.handleDec() }}>-</button> <span style={{color: "red",backgroundColor:"blue"}}>Count - {this.state.Count}</span > <button onClick={() => { this.handleInc() }}>+</button>
      </>
    )
  }
}
export default App;

--here in the above example, setState() is a method that is used to change the value
--state is simply an object that used to store the data
--we can also update directly the value but it will not reflect in the render because render is called only once
--but in setState() after updation the render is called automatically.
--In onClick, function is called with arrow function why because if we write directly means without clicking the button it will be called, if we use arrow function means it wont call until we click.
--And important is the object name state is must be state only other names not work.


--Life Cycle of components--
There are 3 phases
1. Mounting phase
2. Updation phase
3. Unmounting phase

In mounting, 4 phases present
1. Constructor is called(Because of class component)
2. render method is called
3. child methods are called
4. componenetDidMount is called 

--when we want to make an API call we need to write in componenetDidMount() method only why because we will set the value to state so if we write inside the render method means everytime state update there will be render call and it keep on going. So we write in the componenetDidMount()

Day-4(23-11-25)

Props: 
--These are the values passed to the components
Ex:
<Home 
a="Sai"
c={10}
d={[10,20,30]}
oj={{a:10,c:"Sai"}}
/>
--Like this we can pass values, for values other than strings we have to pass with in {}.
--We can access the values like {this.props.a} like this in clild Component

Updation cycle:
--Here first ShouldComponentUpdate() method is called 
then render() method is called
then child Component are called
then ComponentDidUpdate() method is called

--ShouldComponentUpdate() is written like this
ShouldComponentUpdate(nextState,nextProp){
if(this.state.count==nextState.count)
{return false}
else
{return false}
}

--this is for state checking 
--Same for prop checking also but in child Component

--ComponentDidUpdate() method is used if you do anything after any updation happend

Unmount cycle:
--ComponentWillUnmount() method is called when no longer the child method is called(Like by removing the child Component from main cComponent)
--this method is useful when you want to remove the local storage or any other this from the Component.

All these are used in the class based Component but after introduction of hooks now everyone are using the function based Component

--In the above the ShouldComponentUpdate() is used to check updated or not, but we have alternate method to do the same that is PureComponent is imported which will automatically check the updation
--So insted of component in extends(class declaration) we have to use PureComponent

--At the time of document load the react will create the virtual DOM(lightweight copy of the dom) that is a lightweight, so when there is a change in the webpage then this virtual dom will compare the both the doms and apply the changes in that dom only, so there is so much of fastness this is called as "ReConcillation" process.
--This is why the react is fast.
--When the state is updated then the virtual dom will compare with the original dom and then changes are displayed and the old virtual dom will turn to new virtual dom.

Hooks:
--Hooks are simplay functions in react that allow us to use states and other react features like life cycle methods
--It is introduced in v-16.8


(11-25-2025)
--Function based components
--useState() is used to create the state like in class component.
--This will return 2 things(value,function), function is used to update the value
--var [val,setVal] = useState(10)	(here destructuring happening)
--destructuring means saving the values directly that are present in the other value
--We can pass any kind of values like objects,arrays etc
--setVal(20)	this function is for setting the value 

useEffect() hook:
--This is the combination of componenetDidMount() and componenetDidUpdate()
--It is called in rendering and also updation
Ex: useEffect(()=>{})
--If you want to execute componenetDidMount(), we have to pass a second argument [] array to the hook
Ex: useEffect(()=>{},[])
--In the above, in array we have to pass a value that you want to make the that particular thing as componenetDidUpdate()
Ex:
If we have two states,
const[val1,setVal1] = useState(0);
const[val2,setVal2] = useState(0);

useEffect(()=>{},[val2])
if we pass like this means it will work like componenetDidUpdate() for val2 only.

--To ComponentWillUnmount() method(which will execute when the component is right before removed or destroyed form the dom) we have to write like this
Ex: useEffect(()=>{
return ()=>{}
})

--controlled components is the inputs from the components are handled by the state(like binding the values from the state)



(26-11-25)h
--The things that are rendering depends on condition is called conditional rendering.

To make a call synchronous we have to pass like this
function handleInc(){
	setCount((prevVal)=>{
		return prevVal+1
	})
	setCount((prevVal)=>{
		return prevVal+1
	})
	setCount((prevVal)=>{
		return prevVal+1
	})
}
now this is synchronous we  can this when previous state is depends on next state.

(27/11/25)W
Routing:
--To use routing in react we have to install "react-rouder-dom"
--We have to import BrowserRouter from the above package
-- BrowserRouter is a component that is used make sync with router and HTML history.
--It will allow navigations and different routs for different components.
Ex:
<>
      <BrowserRouter>
      <Home />
        <Routes>
          <Route path="/" />
          <Route path="/About" element={<About />} />
          <Route path="/Contact" element={<Contact />} />
          <Route path="*" element={<p> Page not found </p>} />
        </Routes>
      </BrowserRouter>
    </>

--In the above all the routes are keep inside the <Routes>
--If you want to make a component static for all routes, we have place above the <Routes> like we put the <Home /> component.
--To make a link in react we have to use Link tag coming from the "react-rouder-dom"
-- We need to import "react-rouder-dom" in the child components to give links
Ex: <Link to={"/About"}> About </Link>
--So that the page wont be refreshed 
-- If we use direct ancor tag means the page will be refreshed.

--(28-11-25)
--We cannot pass data from child component to parent component but we can pass from parent to child called props
--But we can control the data of parent component in child component by passing the function in props
--In child component the function is being called 
--If we to access the child component in the parent component that we have to declare in the parent component and set the value(By passing function in prop) in the parent child component this is called "state up lifting"

--If you want to make an active link we have to use NavLink insted of Link
Ex: <NavLink to="/Products" activeClassName="active"> Products </NavLink>
    <NavLink to="/" activeClassName="active"> Home </NavLink>

after this we can give styles to active class 
--Here what happens is when we click on a link that link element will get the active as class name and not for remaining


(03-12-25)
--useNavigate() is hook used to pass the parameters through url
--useParams() is a hook that is used to get the values from the url.
--These 2 are coming from the "react-router-dom"
--propTypes is used to set the datatype of the props
--We need to import propTypes (import PropTypes from 'prop-types')
Ex : 
function UserProfile(props) {
  return (
    <div>
      <h1>{props.name}</h1>
      <p>Age: {props.age}</p>
    </div>
  );
}

UserProfile.propTypes = {
  name: PropTypes.string, // 'name' must be a string and is required
  age: PropTypes.number,             // 'age' must be a number, but is optional
};

--Here if age is string passed as string means it will show an warning in the console
--PropTypes.string.isRequired (this make the value as required value)
-- Basic Types: PropTypes.string, PropTypes.number, PropTypes.bool, PropTypes.func, PropTypes.object, PropTypes.array, PropTypes.symbol
--PropTypes.any.isRequired (this means the value should be any of type but it is required)
--PropTypes.oneOfType([PropTypes.string, PropTypes.number]) (this means the value should one of type string or number)
--PropTypes.oneOf(["Loading","Ready"]) (this means the value should be "Loading","Ready" only)

--useMemo is another hook that is used to execute a function when ever an update happend and not execute when not required.
Ex:
let amount = 10;
let value = useMemo(() => {
for (let i = 0; i < 1000000000; i++) {} // slow loop
    return num * 2;
},amount)

--Here in the above example useMemo is executed when the amount is updated only
--The main purpose this is to avoid unnecessary calling of the function and it return a value.

Higher order components
--Is a patterns where a functions receives component as an argument and return a new component that is enhanced version of sended component

--useCallBack()
--In a component if we written internal helper function that if we update the state the entire component is recreated, that will create the internal function also but we dont need actually 
So to avoid this we have to use useCallBack() hook
Ex: 
let fun = useCallBack(()=>{
setCount(count + 1);
},[count])

--React.memo() is used to avoid render the component if there is no change in the value
Ex:
let fun = React.memo((props)=>{
return (<button onClick(()={ props.increaseValue})>Increase</button>)
})

--The main difference b/w useMemo and useCallBack is useMemo will return a value where as useCallBack will return a function and shop recreating the function if not state update
