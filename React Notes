**---------------------- React Notes -----------------------------**

**Day-1 :**

node -v 	-- to check the version of the node
npx create-react-app my-app	--to create react app with basic structure
npm start	-- to start the app(need to run to go to inside the folder "my-app")

Day-2:
Package.json	--contains all the required libraries that are declared like versions
ReactApp	--contains only one index page (Present in public folder)
--All the components are rendered in index under div with id called root
--this happens because of index.js which is entry point
--Node modules contains all the packages
--npm install packageName (used to install packages)
--to access a component we have to write like this
<ComponetName />
--all the components are rendered in index.js
--package-lock.json	--locks the version of the package to use same version for all developers
--the code writing in components is not html it is JSX(javascript XML)
--React.CreateElement("h1",{},"This is head")	--this is used for creating elements in react
above the 2nd object is the parameters to the tag like style etc
--but it heavy for large page
--So Bable(a tool) came to convert the jsx code to react element
--in JSX we call elements and also functions
let head=<h2>Hi</h2>	this is posible


**Day-3 :**

--Inline styling in react is written as object form inside the {}

Ex: <h1 style = { {color:red, backgroundColor:blue} }></h1>

--here backgroundColor is must be in Camal casing not like background-color

exports are 2 types

1. named	declare export before the class
2. default	declare at the end of the file

--In a file many named exports will be present but only one default export

--default exports can be declares any name in import but named exports must have the same name and imported using like  "{App}"

Ex: 
For import--
import App,{About} from "./Tab"	(here About is named and App is default)
For export--
default -- export default App
named -- export class();

--In react class declaration for element is declared using the className;
Ex: <h1 className="Head"></h1>

--index.module.css, a file created like this which is called as css modules in react which contains all the styles and the extension must me ".module.css"
--we have import like this	(import styles as "./index.module.css")
and access like this	(styles.property) why because it will return an object

--direct css import will create confusion because if we use the same class name for other elements, the styles will be applied to that element also without necessary
direct import	--import "./index.css"

--<React.Fragment>
<h2>This is heading</h2>
<p>This is para</p>
</React.Fragment>
--the above is used to return multiple elements without div
--in general we are allowed to return only one element, so to multiple we need to put inside a div, but it will create an extra div which is not required. So we use Fragment
-- the short hand property for Fragment is 
<>
</>

--Components can be created in 2 ways in react 
1. class based
2. function based
Now a days only function based are creating.
Ex: For class component
class App extends Component {
  //Count = 0;
  state = {
    Count: 0
  }
  handleInc() {
    this.setState({ Count: this.state.Count + 1 })
  }
  handleDec() {
    this.setState({ Count: this.state.Count - 1 })
  }
  render() {
    return (
      <>
        <button onClick={() => { this.handleDec() }}>-</button> <span style={{color: "red",backgroundColor:"blue"}}>Count - {this.state.Count}</span > <button onClick={() => { this.handleInc() }}>+</button>
      </>
    )
  }
}
export default App;

--here in the above example, setState() is a method that is used to change the value
--state is simply an object that used to store the data
--we can also update directly the value but it will not reflect in the render because render is called only once
--but in setState() after updation the render is called automatically.
--In onClick, function is called with arrow function why because if we write directly means without clicking the button it will be called, if we use arrow function means it wont call until we click.
--And important is the object name state is must be state only other names not work.


--Life Cycle of components--
There are 3 phases
1. Mounting phase
2. Updation phase
3. Unmounting phase

In mounting, 4 phases present
1. Constructor is called(Because of class component)
2. render method is called
3. child methods are called
4. componenetDidMount is called 

--when we want to make an API call we need to write in componenetDidMount() method only why because we will set the value to state so if we write inside the render method means everytime state update there will be render call and it keep on going. So we write in the componenetDidMount()

Day-4(23-11-25)

Props: 
--These are the values passed to the components
Ex:
<Home 
a="Sai"
c={10}
d={[10,20,30]}
oj={{a:10,c:"Sai"}}
/>
--Like this we can pass values, for values other than strings we have to pass with in {}.
--We can access the values like {this.props.a} like this in clild Component

Updation cycle:
--Here first ShouldComponentUpdate() method is called 
then render() method is called
then child Component are called
then ComponentDidUpdate() method is called

--ShouldComponentUpdate() is written like this
ShouldComponentUpdate(nextState,nextProp){
if(this.state.count==nextState.count)
{return false}
else
{return false}
}

--this is for state checking 
--Same for prop checking also but in child Component

--ComponentDidUpdate() method is used if you do anything after any updation happend

Unmount cycle:
--ComponentWillUnmount() method is called when no longer the child method is called(Like by removing the child Component from main cComponent)
--this method is useful when you want to remove the local storage or any other this from the Component.

All these are used in the class based Component but after introduction of hooks now everyone are using the function based Component

--In the above the ShouldComponentUpdate() is used to check updated or not, but we have alternate method to do the same that is PureComponent is imported which will automatically check the updation
--So insted of component in extends(class declaration) we have to use PureComponent

--At the time of document load the react will create the virtual DOM(lightweight copy of the dom) that is a lightweight, so when there is a change in the webpage then this virtual dom will compare the both the doms and apply the changes in that dom only, so there is so much of fastness this is called as "ReConcillation" process.
--This is why the react is fast.
--When the state is updated then the virtual dom will compare with the original dom and then changes are displayed and the old virtual dom will turn to new virtual dom.

Hooks:
--Hooks are simplay functions in react that allow us to use states and other react features like life cycle methods
--It is introduced in v-16.8


(11-25-2025)
--Function based components
--useState() is used to create the state like in class component.
--This will return 2 things(value,function), function is used to update the value
--var [val,setVal] = useState(10)	(here destructuring happening)
--destructuring means saving the values directly that are present in the other value
--We can pass any kind of values like objects,arrays etc
--setVal(20)	this function is for setting the value 

useEffect() hook:
--This is the combination of componenetDidMount() and componenetDidUpdate()
--It is called in rendering and also updation
Ex: useEffect(()=>{})
--If you want to execute componenetDidMount(), we have to pass a second argument [] array to the hook
Ex: useEffect(()=>{},[])
--In the above, in array we have to pass a value that you want to make the that particular thing as componenetDidUpdate()
Ex:
If we have two states,
const[val1,setVal1] = useState(0);
const[val2,setVal2] = useState(0);

useEffect(()=>{},[val2])
if we pass like this means it will work like componenetDidUpdate() for val2 only.

--To ComponentWillUnmount() method(which will execute when the component is right before removed or destroyed form the dom) we have to write like this
Ex: useEffect(()=>{
return ()=>{}
})

--controlled components is the inputs from the components are handled by the state(like binding the values from the state)



(26-11-25)h
--The things that are rendering depends on condition is called conditional rendering.

To make a call synchronous we have to pass like this
function handleInc(){
	setCount((prevVal)=>{
		return prevVal+1
	})
	setCount((prevVal)=>{
		return prevVal+1
	})
	setCount((prevVal)=>{
		return prevVal+1
	})
}
now this is synchronous we  can this when previous state is depends on next state.

(27/11/25)W
Routing:
--To use routing in react we have to install "react-rouder-dom"
--We have to import BrowserRouter from the above package
-- BrowserRouter is a component that is used make sync with router and HTML history.
--It will allow navigations and different routs for different components.
Ex:
<>
      <BrowserRouter>
      <Home />
        <Routes>
          <Route path="/" />
          <Route path="/About" element={<About />} />
          <Route path="/Contact" element={<Contact />} />
          <Route path="*" element={<p> Page not found </p>} />
        </Routes>
      </BrowserRouter>
    </>

--In the above all the routes are keep inside the <Routes>
--If you want to make a component static for all routes, we have place above the <Routes> like we put the <Home /> component.
--To make a link in react we have to use Link tag coming from the "react-rouder-dom"
-- We need to import "react-rouder-dom" in the child components to give links
Ex: <Link to={"/About"}> About </Link>
--So that the page wont be refreshed 
-- If we use direct ancor tag means the page will be refreshed.

--(28-11-25)
--We cannot pass data from child component to parent component but we can pass from parent to child called props
--But we can control the data of parent component in child component by passing the function in props
--In child component the function is being called 
--If we to access the child component in the parent component that we have to declare in the parent component and set the value(By passing function in prop) in the parent child component this is called "state up lifting"

--If you want to make an active link we have to use NavLink insted of Link
Ex: <NavLink to="/Products" activeClassName="active"> Products </NavLink>
    <NavLink to="/" activeClassName="active"> Home </NavLink>

after this we can give styles to active class 
--Here what happens is when we click on a link that link element will get the active as class name and not for remaining

(03-12-25)
--useNavigate() is hook used to pass the parameters through url
--useParams() is a hook that is used to get the values from the url.
--These 2 are coming from the "react-router-dom"
--propTypes is used to set the datatype of the props
--We need to import propTypes (import PropTypes from 'prop-types')
Ex : 
function UserProfile(props) {
  return (
    <div>
      <h1>{props.name}</h1>
      <p>Age: {props.age}</p>
    </div>
  );
}

UserProfile.propTypes = {
  name: PropTypes.string, // 'name' must be a string and is required
  age: PropTypes.number,             // 'age' must be a number, but is optional
};

--Here if age is string passed as string means it will show an warning in the console
--PropTypes.string.isRequired (this make the value as required value)
-- Basic Types: PropTypes.string, PropTypes.number, PropTypes.bool, PropTypes.func, PropTypes.object, PropTypes.array, PropTypes.symbol
--PropTypes.any.isRequired (this means the value should be any of type but it is required)
--PropTypes.oneOfType([PropTypes.string, PropTypes.number]) (this means the value should one of type string or number)
--PropTypes.oneOf(["Loading","Ready"]) (this means the value should be "Loading","Ready" only)

--useMemo is another hook that is used to execute a function when ever an update happend and not execute when not required.
Ex:
let amount = 10;
let value = useMemo(() => {
for (let i = 0; i < 1000000000; i++) {} // slow loop
    return num * 2;
},amount)

--Here in the above example useMemo is executed when the amount is updated only
--The main purpose this is to avoid unnecessary calling of the function and it return a value.

Higher order components
--Is a patterns where a functions receives component as an argument and return a new component that is enhanced version of sended component

--useCallBack()
--In a component if we written internal helper function that if we update the state the entire component is recreated, that will create the internal function also but we dont need actually 
So to avoid this we have to use useCallBack() hook
Ex: 
let fun = useCallBack(()=>{
setCount(count + 1);
},[count])

--React.memo() is used to avoid render the component if there is no change in the value
Ex:
let fun = React.memo((props)=>{
return (<button onClick(()={ props.increaseValue})>Increase</button>)
})

--The main difference b/w useMemo and useCallBack is useMemo will return a value where as useCallBack will return a function and shop recreating the function if not state update

(4-12-2025)
--Prop drilling is the process of sending the data to other components by passings to its parents components.
Ex: If we have 3 components App, Home and Profile, App is the parent of remaining 2 components, if we want to send the data from Home to profile component than we have to pass first to parent component App and then to Profile (directly not posible).
-- The entire above process is called as prop drilling.

--But this is not a good process because we are unnecessarily passing the data.
--We can avoid this by using redux.

Redux:
It is central store for storing the data
--If you want to access data from redux first the component need to subscribe to the redux.
--Only the reducer can able to add or update the data in the redux.
--To use redux we need to import "react-redux" and "redux"
--reducer is just a function(component) that return something the value that is returned will be stored in redux
let reducer = (state,action)=>{
return state;
}

--To setup a redux store we have to import createStore from redux and Provider from the react-redux.
let reduxStore = createStore(reducer)
Provider is imported because we have created the store but react dont know it so we need to do this.
<provider store = {reduxStore}>
<App />
</provider >

--Like this we need to declare components inside the Provider and pass the store as a prop.
--To access the data in redux inside the component we have to subscribe 
--To do it we need to import connect from the "react-redux"
--And in export we have to like this

let mapStateToProps = (state)=>{
  return state;
}
export default connect(mapStateToProps)(App);
--Here now the redux data is passed to the App component.
--The above syntax is calling the inner function that is present in a function.
Ex: 
function outerFunction(){
return innerFunction(){}
}
Here to call the innerFunction we have to follow the syntax.(outerFunction()())

--Upto now we have created the store and access the data in App component
--redux data update--
--To do this we need dispatch an action to reducer
Ex: 
let mapDispatchToProps = (Dispatch) => {
  return {
    changeName: () => {
      Dispatch({ type: "change_Name", payload: "b" })
    }
  }
}
export default connect(mapStateToProps, mapDispatchToProps)(App);
in App component (<button onClick={()=>{props.changeName("b")}}>ChangeName</button>)
--Now a dispatch is issued
--Now we have to handle this dispatch in the redurer and change the data 
Ex: 
Reducer.js
let userData = { Name:"a", Age:20 }
const Reducer = (state=userData,action)=>{
    if(action.type == "change_Name"){
        return {
            ...state,	//This is using to avoid loss of data
            Name : action.payload
        }
    }
    return state;
}
export default Reducer

--Like this we can update the data in the redux 
--Now we can able to access the data in other components by creating subscribing
Ex:
Child.js
import { connect } from "react-redux"
const Child1 = (props) => {
return(
    <>
    <p>Name: {props.Name}</p>
    </>
)
}
let makeStateToProp = (state) => {
    return state
}
export default connect(makeStateToProp)(Child1)

--Simply we can create redux in these steps
1. Create store and say to react using provider(By installing "redux", "react-redux" and import createStore from redux)
2. Access the values by creating subscription (importing the connect from react-redux)
3. create reducer for updation (separate component for reducer and handle dispatch actions)


(06-12-25)
Redux Thunk:
--Generally if we want to perform an api and store the data in redux we have to make a call in dispatch
Ex: 
let mapDispatchToProps = (Dispatch) => {
  return {
    changeName: () => {
	axios.get("url").then((res)=>{
		Dispatch({ type: "change_Name", payload: res.data[0].Name })
		})
    }
  }
}
Like this we have to do
--But Redux Thunk is used to do it 
--So it is a special helper that is used to make async task operations(Like API calls) before dispatching the state. It is a middleware that will return a function instead of plain object.
--To implement this we need one more package that is "redux-thunk"
--Import thunk from "redux-thunk" and addMiddleware from redux
--Now we have to pass a middleware
Ex: let reduxStore = createStore(reducer,addMiddleware(thunk))

--After this we have to do like this
Ex: 
let thunk = ()=>{
	axios.get("url").then((res)=>{
		Dispatch({ type: "change_Name", payload: res.data[0].Name })
		})
}
let mapDispatchToProps = (Dispatch) => {
  return {
    changeName: () => {
	Dispatch(thunk())
    }
  }
}
--Now we are passing function as argument insted of plain object

Redux Toolkit:
--Before this all people feel like 
1. Difficult to implement
2. Adding more packages
3. More code

--After this the thinks become easy

Steps:
For Creation:
--To implement this we need to install "@reduxjs/toolkit"
--To create store we have to import configureStore hook from "@reduxjs/toolkit" and 
let store = configureStore({
  reducer : Reducer
})

This store is passed as store for provider.

In reducer:
--we have import createReducer from "@reduxjs/toolkit" and create write like this
import { createReducer } from "@reduxjs/toolkit"

let initialState = {
Name:"a",Age:10
}
const Reducer = createReducer(initialState, (builder)=>{
    
})
export default Reducer

--So now the data is sored in the redux

For Subscription:
--Need to import useSelector hook from "react-redux" and create like this
Ex:
import { useSelector } from "react-redux";
const App = ()=>{
  let Name = useSelector((state)=>{
    return state.Name	//Here we need to get only the required data 
  })
return(
  <>
  <p>Name = {Name}</p>
  </>
)
}
export default App

For dispatch:
--We need to import useDispatch from "react-redux" and write like this
Ex:
import { useSelector,useDispatch } from "react-redux";
const App = ()=>{
  let Name = useSelector((state)=>{
    return state.Name
  })
  let dispatch = useDispatch();
return(
  <>
  <p>Name = {Name}</p>
  <button onClick={()=>{dispatch({type:"change_Name",payload:"b"})}}> Change Name</button>
  </>
)
}
export default App
--Now dispatch is issued

For handling in reducer:
--Handling is done by like this in reducer
Ex:
import { createReducer } from "@reduxjs/toolkit"
let initialState = {
Name:"a",Age:10
}
const Reducer = createReducer(initialState, (builder)=>{
    builder.addCase("change_Name",(state,action)=>{
        state.Name = action.payload
    })

    builder.addCase("change_Age",(state,action)=>{
        state.Age = action.payload
    })

})
export default Reducer

--Here how many actions we want to handel that many addCase methods we have to create
