**---------------------- React Notes -----------------------------**

**Day-1 :**

node -v 	-- to check the version of the node
npx create-react-app my-app	--to create react app with basic structure
npm start	-- to start the app(need to run to go to inside the folder "my-app")

Day-2:
Package.json	--contains all the required libraries that are declared like versions
ReactApp	--contains only one index page (Present in public folder)
--All the components are rendered in index under div with id called root
--this happens because of index.js which is entry point
--Node modules contains all the packages
--npm install packageName (used to install packages)
--to access a component we have to write like this
<ComponetName />
--all the components are rendered in index.js
--package-lock.json	--locks the version of the package to use same version for all developers
--the code writing in components is not html it is JSX(javascript XML)
--React.CreateElement("h1",{},"This is head")	--this is used for creating elements in react
above the 2nd object is the parameters to the tag like style etc
--but it heavy for large page
--So Bable(a tool) came to convert the jsx code to react element
--in JSX we call elements and also functions
let head=<h2>Hi</h2>	this is posible


**Day-3 :**

--Inline styling in react is written as object form inside the {}

Ex: <h1 style = { {color:red, backgroundColor:blue} }></h1>

--here backgroundColor is must be in Camal casing not like background-color

exports are 2 types

1. named	declare export before the class
2. default	declare at the end of the file

--In a file many named exports will be present but only one default export

--default exports can be declares any name in import but named exports must have the same name and imported using like  "{App}"

Ex: 
For import--
import App,{About} from "./Tab"	(here About is named and App is default)
For export--
default -- export default App
named -- export class();

--In react class declaration for element is declared using the className;
Ex: <h1 className="Head"></h1>

--index.module.css, a file created like this which is called as css modules in react which contains all the styles and the extension must me ".module.css"
--we have import like this	(import styles as "./index.module.css")
and access like this	(styles.property) why because it will return an object

--direct css import will create confusion because if we use the same class name for other elements, the styles will be applied to that element also without necessary
direct import	--import "./index.css"

--<React.Fragment>
<h2>This is heading</h2>
<p>This is para</p>
</React.Fragment>
--the above is used to return multiple elements without div
--in general we are allowed to return only one element, so to multiple we need to put inside a div, but it will create an extra div which is not required. So we use Fragment
-- the short hand property for Fragment is 
<>
</>

--Components can be created in 2 ways in react 
1. class based
2. function based
Now a days only function based are creating.
Ex: For class component
class App extends Component {
  //Count = 0;
  state = {
    Count: 0
  }
  handleInc() {
    this.setState({ Count: this.state.Count + 1 })
  }
  handleDec() {
    this.setState({ Count: this.state.Count - 1 })
  }
  render() {
    return (
      <>
        <button onClick={() => { this.handleDec() }}>-</button> <span style={{color: "red",backgroundColor:"blue"}}>Count - {this.state.Count}</span > <button onClick={() => { this.handleInc() }}>+</button>
      </>
    )
  }
}
export default App;

--here in the above example, setState() is a method that is used to change the value
--state is simply an object that used to store the data
--we can also update directly the value but it will not reflect in the render because render is called only once
--but in setState() after updation the render is called automatically.
--In onClick, function is called with arrow function why because if we write directly means without clicking the button it will be called, if we use arrow function means it wont call until we click.
--And important is the object name state is must be state only other names not work.


--Life Cycle of components--
There are 3 phases
1. Mounting phase
2. Updation phase
3. Unmounting phase

In mounting, 4 phases present
1. Constructor is called(Because of class component)
2. render method is called
3. child methods are called
4. componenetDidMount is called 

--when we want to make an API call we need to write in componenetDidMount() method only why because we will set the value to state so if we write inside the render method means everytime state update there will be render call and it keep on going. So we write in the componenetDidMount()

Day-4(23-11-25)

Props: 
--These are the values passed to the components
Ex:
<Home 
a="Sai"
c={10}
d={[10,20,30]}
oj={{a:10,c:"Sai"}}
/>
--Like this we can pass values, for values other than strings we have to pass with in {}.
--We can access the values like {this.props.a} like this in clild Component

Updation cycle:
--Here first ShouldComponentUpdate() method is called 
then render() method is called
then child Component are called
then ComponentDidUpdate() method is called

--ShouldComponentUpdate() is written like this
ShouldComponentUpdate(nextState,nextProp){
if(this.state.count==nextState.count)
{return false}
else
{return false}
}

--this is for state checking 
--Same for prop checking also but in child Component

--ComponentDidUpdate() method is used if you do anything after any updation happend

Unmount cycle:
--ComponentWillUnmount() method is called when no longer the child method is called(Like by removing the child Component from main cComponent)
--this method is useful when you want to remove the local storage or any other this from the Component.

All these are used in the class based Component but after introduction of hooks now everyone are using the function based Component

--In the above the ShouldComponentUpdate() is used to check updated or not, but we have alternate method to do the same that is PureComponent is imported which will automatically check the updation
--So insted of component in extends(class declaration) we have to use PureComponent

--At the time of document load the react will create the virtual DOM(lightweight copy of the dom) that is a lightweight, so when there is a change in the webpage then this virtual dom will compare the both the doms and apply the changes in that dom only, so there is so much of fastness this is called as "ReConcillation" process.
--This is why the react is fast.
--When the state is updated then the virtual dom will compare with the original dom and then changes are displayed and the old virtual dom will turn to new virtual dom.

Hooks:
--Hooks are simplay functions in react that allow us to use states and other react features like life cycle methods
--It is introduced in v-16.8


(11-25-2025)
--Function based components
--useState() is used to create the state like in class component.
--This will return 2 things(value,function), function is used to update the value
--var [val,setVal] = useState(10)	(here destructuring happening)
--destructuring means saving the values directly that are present in the other value
--We can pass any kind of values like objects,arrays etc
--setVal(20)	this function is for setting the value 

useEffect() hook:
--This is the combination of componenetDidMount() and componenetDidUpdate()
--It is called in rendering and also updation
Ex: useEffect(()=>{})
--If you want to execute componenetDidMount(), we have to pass a second argument [] array to the hook
Ex: useEffect(()=>{},[])
--In the above, in array we have to pass a value that you want to make the that particular thing as componenetDidUpdate()
Ex:
If we have two states,
const[val1,setVal1] = useState(0);
const[val2,setVal2] = useState(0);

useEffect(()=>{},[val2])
if we pass like this means it will work like componenetDidUpdate() for val2 only.

--To ComponentWillUnmount() method(which will execute when the component is right before removed or destroyed form the dom) we have to write like this
Ex: useEffect(()=>{
return ()=>{}
})

--controlled components is the inputs from the components are handled by the state(like binding the values from the state)



(26-11-25)h
--The things that are rendering depends on condition is called conditional rendering.

To make a call synchronous we have to pass like this
function handleInc(){
	setCount((prevVal)=>{
		return prevVal+1
	})
	setCount((prevVal)=>{
		return prevVal+1
	})
	setCount((prevVal)=>{
		return prevVal+1
	})
}
now this is synchronous we  can this when previous state is depends on next state.

(27/11/25)W
Routing:
--To use routing in react we have to install "react-rouder-dom"
--We have to import BrowserRouter from the above package
-- BrowserRouter is a component that is used make sync with router and HTML history.
--It will allow navigations and different routs for different components.
Ex:
<>
      <BrowserRouter>
      <Home />
        <Routes>
          <Route path="/" />
          <Route path="/About" element={<About />} />
          <Route path="/Contact" element={<Contact />} />
          <Route path="*" element={<p> Page not found </p>} />
        </Routes>
      </BrowserRouter>
    </>

--In the above all the routes are keep inside the <Routes>
--If you want to make a component static for all routes, we have place above the <Routes> like we put the <Home /> component.
--To make a link in react we have to use Link tag coming from the "react-rouder-dom"
-- We need to import "react-rouder-dom" in the child components to give links
Ex: <Link to={"/About"}> About </Link>
--So that the page wont be refreshed 
-- If we use direct ancor tag means the page will be refreshed.
